\PassOptionsToPackage{table}{xcolor}
\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc} % UTF-8 Kodierung verwenden
\usepackage[backend=biber, sorting=none]{biblatex}
\addbibresource{P2_De-Novo-Sequencing using Spectrum-Graphs.bib}
\usepackage[total={6.5in, 9in}]{geometry}
% \usepackage[onehalfspacing]{setspace} % 1.5 Spacing
\usepackage[singlespacing]{setspace} % 1 Spacing
\usepackage[T1]{fontenc}    % Fonts mit westeuropäischer Codierung verwenden
\usepackage[ngerman]{babel} % Neue deutsche Sprache
\usepackage{csquotes}
\usepackage{fancyhdr}       % Kopf- und Fusszeilen
\usepackage{tikz}           % Fuer das Erstellen von einfachen Grafiken
\usepackage{tkz-berge}
\usepackage{pifont}
\usepackage{makecell}
\usepackage{titleref}
\usepackage{booktabs}
\usepackage{float}          % Fuer den Positionierungsbefehl '[H]'
\usepackage{fancyhdr}       % Angepasste Header und Footer
\usepackage{titling}        % Fuer Befehle wie \thetitle
% \usepackage{showframe}     % Boxen mit Rand visualisieren (nur für das Schreiben des Dokuments brauchbar!)
\usepackage{translator}
\usepackage{subcaption}
\usepackage{caption}
\usepackage[
nonumberlist, %keine Seitenzahlen anzeigen
%acronym,      %ein Abkürzungsverzeichnis erstellen
toc,          %Einträge im Inhaltsverzeichnis
section,      %im Inhaltsverzeichnis auf section-Ebene erscheinen
nopostdot     %Den Punkt am Ende jeder Beschreibung deaktivieren
]{glossaries}
\makenoidxglossaries

% \setlength{\abovecaptionskip}{1ex}
% \setlength{\belowcaptionskip}{1ex}
\setlength{\floatsep}{24pt}
\setlength{\textfloatsep}{24pt}
\setlength{\headheight}{15pt}

\setcounter{tocdepth}{1}

\title{De-Novo-Sequencing using Spectrum-Graphs, enabling Open Searches}
\author{Dominik Habermann}
\date{\today}

% Kopf- und Fussnoten anpassen
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\thetitle}
%\fancyhead[R]{\thetitle}
\fancyfoot[C]{\thepage}


% Glossar- und Abkürzungsverzeichnis
\input{./Resources/P2_De-Novo-Sequencing using Spectrum-Graphs.gls}
\input{./Resources/P2_De-Novo-Sequencing using Spectrum-Graphs.acr}

\newcommand{\gerquot}[1]{\glqq#1\grqq}
\newcommand{\dashAndSpace}{\textendash \space}
\newcommand{\dashAndSpaceSeq}[1]{\dashAndSpace#1 \dashAndSpace}
\newcommand{\tikzScale}{1.15}
\newcommand{\xAxisUnit}{$m/z$}
\newcommand{\yAxisUnit}{$y$}

\renewcommand{\floatpagefraction}{0.8}
% Workaround um die Überschrift des Glossars anzupassen
% Siehe: https://tex.stackexchange.com/questions/426390/how-can-i-rename-the-header-titles-of-the-glossary
\addto\captionsngerman
{%
    \renewcommand*{\glossaryname}{Begriffserklärungen}%
}



%%%%% %%%%% %%%%% %%%%% %%%%% \begin{document} %%%%% %%%%% %%%%% %%%%% %%%%%
\begin{document}

\maketitle

\section{Einleitung}
Im ersten Kapitel findet zu Beginn eine Erklärung der wichtigsten Begriffe und Abkürzungen statt. Dazu wird eine Themenabgrenzung durchgeführt sowie die Ausgangssituation beschrieben.

\printnoidxglossaries

\subsection{Themenabgrenzung}
Folgende Aspekte sind Bestandteil dieser Ausarbeitung:
\begin{itemize}
   \item Was ist die \gls{gls:DeNovo}?
   \item Was erhofft man sich von dieser Technologie?
   \item Welche Probleme liegen vor, die von der Seite der Informatik gelöst / verbessert werden können?
   \item Inwiefern spielen die Spektrums-Graphen dabei eine Rolle?
\end{itemize}

\subsection{Ausgangssituation}
Mit Hilfe der \gls{gls:DeNovo} ist grundsätzlich die Bestimmung von unbekannten Aminosäuresequenzen möglich. Das Verfahren arbeitet allerdings nicht in jeder Situation zuverlässig genug. Dadurch wird das Ermitteln von unbekannten Sequenzen erschwert. Auch bei bereits bekannten Sequenzen führt die nicht ausreichende Zuverlässigkeit dazu, dass bei Ergebnissen nicht sicher unterschieden werden kann, ob eine Änderung in der Aminosäuresequenz vorliegt oder ob fehlerhafte Daten bestimmt wurden.
Das Ziel ist mit Unterstützung von Software eine Möglichkeit bereitzustellen, um die Zuverlässigkeit der \gls{gls:DeNovo} zu erhöhen. Gleichzeitig soll die Implementierung ein effizienteres Werkzeug darstellen als die bereits verfügbaren Ansätze.


\section{De-Novo-Peptidsequenzierung und \glspl{gls:SpecGraph} im Detail}
In diesem Abschnitt werden die relevanten Herangehensweisen sowohl für die Datengewinnung als auch für deren Auswertung erklärt.

\subsection{Datengewinnung}
Die \gls{gls:DeNovo} nutzt die sogenannte \gls{gls:TMassSpek} für die Bestimmung der Peptidsequenz. Dabei wird die physikalische Eigenschaft ausgenutzt, dass jedes Atom bzw. jedes Molekül \dashAndSpace wenn es einer \gls{gls:Ionisation} unterzogen wurde \dashAndSpace ein charakteristisches \gls{gls:MassSpek} besitzt. Das \gls{gls:MassSpek} stellt also eine Art \gerquot{Fingerabdruck} eines Moleküls dar und macht dieses ermittelbar.

% U.U. eine Beispielgrafik eines Massenspektrums hinzufuegen ...

\subsubsection{\glsentrytext{gls:TMassSpek} bei größeren Molekülen}
Bei größeren Molekülen (wie einem Protein) führt die \gls{gls:Ionisation} dazu, dass das Molekül in kleinere spezifische Ionen zerfällt (sog. Fragmentierung). Die Fragmentierungsinformationen einer \gls{gls:DeNovo} sind meist unvollständig, da fehlende Daten bei einem Fragmentierungsschritt die Güte des Endergebnisses negativ beeinflusst. Dies wird insbesondere dann ein Problem, wenn unbekannte Änderungen in einer Peptidsequenz vorhanden sind.

Um dieses Problem zu verringern können unterschiedliche Techniken parallel eingesetzt werden, welche verschiedene Fragmente erzeugen und daher auch verschiedenartige \glspl{gls:MassSpek} zur Folge haben.\footnote{Konkret: Es wird sowohl das \gls{acr:HCD} als auch das \gls{acr:ETD} Verfahren angewendet.}

\subsection{Datenaufbereitung}
Typischerweise betrachtet man die sog. \gerquot{\glspl{gls:Peak}} in den \glspl{gls:MassSpek}. Jeder \gls{gls:Peak} stellt ein unterschiedliches Ion dar. Dazu kommen Messungenauigkeiten sowie Hintergrundrauschen. Durch die hohe Anzahl an möglichen Ionen kann nicht ohne weiteres differenziert werden, welcher der \glspl{gls:Peak} von welchen Ionen erzeugt wurden und welche nicht.

% Frage an Dominik: Ist hier eine einfache Auflistung an Techniken für die Datenaufbereitung besser?
Der Algorithmus für die Datenaufbereitung berechnet den natürlichen Logarithmus von den Intensitäten der \glspl{gls:Peak}, um Hintergrundrauschen und Messungenauigkeiten nicht überzupriorisieren. Zusätzlich dazu werden \glspl{gls:Peak}, die in einem Toleranzbereich nebeneinander liegen, zusammengefasst. Am Ende werden die \glspl{gls:Peak} entfernt, bei denen bekannt ist, dass es sich nicht um relevante Ionen handeln kann. (z.B. \glspl{gls:Peak} von Isotopen)

\begin{figure}[H]
   \centering
   \begin{minipage}[t]{.4\linewidth}
      \centering
      \begin{tikzpicture}[scale=\tikzScale, baseline=(current bounding box.center)]
         \draw [<->,thick] (0,2.75) node (yaxis) [above] {\yAxisUnit}
         |- (3,0) node (xaxis) [right] {\xAxisUnit};

         \draw[thick] (0.2,0) -- (0.2,1.1);
         \draw[thick] (0.3,0) -- (0.3,1.6);
         \draw[thick] (0.6,0) -- (0.6,1.7);
         \draw[thick] (0.8,0) -- (0.8,1.2);
         \draw[thick] (1.0,0) -- (1.0,1.1);

         \draw[color=red,thick] (1.2,0) -- (1.2,2.65);
         \draw[thick] (1.4,0) -- (1.4,1.4);
         \draw[thick] (1.6,0) -- (1.6,1.2);
         \draw[thick] (1.8,0) -- (1.8,1.3);
         \draw[thick] (2.0,0) -- (2.0,1.8);

         \draw[thick] (1.1,0) -- (1.1,2.0);
         \draw[color=red,thick] (0.35,0) -- (0.35,2.25);
         \draw[thick] (1.9,0) -- (1.9,1.4);
         \draw[color=red,thick] (2.2,0) -- (2.2,2.6);
         \draw[thick] (2.5,0) -- (2.5,1.25);

         \draw[thick] (2.7,0) -- (2.7,1.1);
         \foreach \x in {1,...,6}
         {
            \draw[thick] (1.2+\x*0.05,0) -- (1.2+\x*0.05,1.0+\x*0.15);
         }
      \end{tikzpicture}%
      % \subcaption{Exemplarische Rohdaten}
   \end{minipage}%
   \textbf{$\rightarrow$}
   \begin{minipage}[t]{.4\linewidth}
      \centering
      \begin{tikzpicture}[scale=\tikzScale, baseline=(current bounding box.center)]
         \draw [<->,thick] (0,2.75) node (yaxis) [above] {\yAxisUnit}
         |- (3,0) node (xaxis) [right] {\xAxisUnit};

         \draw[thick] (0.2,0) -- (0.2,{ln(1.1)});
         \draw[thick] (0.3,0) -- (0.3,{ln(1.6)});
         \draw[thick] (0.6,0) -- (0.6,{ln(1.7)});
         \draw[thick] (0.8,0) -- (0.8,{ln(1.2)});
         \draw[thick] (1.0,0) -- (1.0,{ln(1.1)});

         \draw[color=red,thick] (1.2,0) -- (1.2,{ln(2.65)});
         \draw[thick] (1.4,0) -- (1.4,{ln(1.4)});
         \draw[thick] (1.6,0) -- (1.6,{ln(1.2)});
         \draw[thick] (1.8,0) -- (1.8,{ln(1.3)});
         \draw[thick] (2.0,0) -- (2.0,{ln(1.8)});

         \draw[thick] (1.1,0) -- (1.1,{ln(2.0)});
         \draw[color=red,thick] (0.35,0) -- (0.35,{ln(2.25)});
         \draw[thick] (1.9,0) -- (1.9,{ln(1.4)});
         \draw[color=red,thick] (2.2,0) -- (2.2,{ln(2.6)});
         \draw[thick] (2.5,0) -- (2.5,{ln(1.25)});

         \draw[thick] (2.7,0) -- (2.7,{ln(1.1)});
         \foreach \x in {1,...,6}
         {%
            \draw[thick] (1.2+\x*0.05,0) -- (1.2+\x*0.05,{ln(1.0+\x*0.15)});
         }
      \end{tikzpicture}
      %\subcaption{Exemplarische Rohdaten}
   \end{minipage}
   \caption{Anwendung des $ln$ auf Rohdaten. Rote \glspl{gls:Peak} stellen hier exemplarisch fehlerhafte Daten dar, die nach dem $ln$ reduziert wurden.}
\end{figure}

\begin{figure}[H]
   \centering
   \begin{minipage}[t]{.4\linewidth}
      \centering
      \begin{tikzpicture}[scale=\tikzScale, baseline=(current bounding box.center)]
         \draw [<->,thick] (0,2.75) node (yaxis) [above] {\yAxisUnit}
         |- (3,0) node (xaxis) [right] {\xAxisUnit};

         \draw[thick] (0.2,0) -- (0.2,{ln(1.1)});
         \draw[thick] (0.3,0) -- (0.3,{ln(1.6)});
         \draw[thick] (0.6,0) -- (0.6,{ln(1.7)});
         \draw[thick] (0.8,0) -- (0.8,{ln(1.2)});
         \draw[thick] (1.0,0) -- (1.0,{ln(1.1)});

         \draw[thick] (1.2,0) -- (1.2,{ln(2.65)});
         \draw[thick] (1.4,0) -- (1.4,{ln(1.4)});
         \draw[thick] (1.6,0) -- (1.6,{ln(1.2)});
         \draw[thick] (1.8,0) -- (1.8,{ln(1.3)});
         \draw[thick] (2.0,0) -- (2.0,{ln(1.8)});

         \draw[thick] (1.1,0) -- (1.1,{ln(2.0)});
         \draw[thick] (0.35,0) -- (0.35,{ln(2.25)});
         \draw[thick] (1.9,0) -- (1.9,{ln(1.4)});
         \draw[thick] (2.2,0) -- (2.2,{ln(2.6)});
         \draw[thick] (2.5,0) -- (2.5,{ln(1.25)});

         \draw[thick] (2.7,0) -- (2.7,{ln(1.1)});
         \foreach \x in {1,...,6}
         {%
            \draw[color=red,thick] (1.2+\x*0.05,0) -- (1.2+\x*0.05,{ln(1.0+\x*0.15)});
         }

         \draw[dotted] (0.4,0) -- (0.4,2.75);
         \draw[dotted] (2.6,0) -- (2.6,2.75);
         \fill[red!25!,opacity=.25] (0,0) rectangle (0.4,2.75);
         \fill[red!25!,opacity=.25] (2.6,0) rectangle (3.0,2.75);
         \fill[green!25!,opacity=.25] (0.4,0) rectangle (2.6,2.75);
      \end{tikzpicture}
      %\subcaption{Exemplarische Rohdaten}
   \end{minipage}
   \textbf{$\rightarrow$}
   \begin{minipage}[t]{.4\linewidth}
      \centering
      \begin{tikzpicture}[scale=\tikzScale, baseline=(current bounding box.center)]
         \draw [<->,thick] (0,2.75) node (yaxis) [above] {\yAxisUnit}
         |- (3,0) node (xaxis) [right] {\xAxisUnit};

         \draw[thick] (0.6,0) -- (0.6,{ln(1.7)});
         \draw[thick] (0.8,0) -- (0.8,{ln(1.2)});
         \draw[thick] (1.0,0) -- (1.0,{ln(1.1)});

         \draw[thick] (1.2,0) -- (1.2,{ln(2.65)});
         %\draw[thick] (1.4,0) -- (1.4,{ln(1.4)});
         \draw[thick] (1.6,0) -- (1.6,{ln(1.2)});
         \draw[thick] (1.8,0) -- (1.8,{ln(1.3)});
         \draw[thick] (2.0,0) -- (2.0,{ln(1.8)});

         \draw[thick] (1.1,0) -- (1.1,{ln(2.0)});
         \draw[thick] (1.9,0) -- (1.9,{ln(1.4)});
         \draw[thick] (2.2,0) -- (2.2,{ln(2.6)});
         \draw[thick] (2.5,0) -- (2.5,{ln(1.25)});

         \draw[color=red,ultra thick] (1.2+1*0.05,0) -- (1.2+1*0.05,{ln(1.0+1*0.15)});
         \draw[color=red,ultra thick] (1.2+3*0.05,0) -- (1.2+3*0.05,{ln(1.0+3*0.15)});
         \draw[color=red,ultra thick] (1.2+5*0.05,0) -- (1.2+5*0.05,{ln(1.0+5*0.15)});

         \draw[dotted] (0.4,0) -- (0.4,2.75);
         \draw[dotted] (2.6,0) -- (2.6,2.75);
         \fill[red!25!,opacity=.25] (0,0) rectangle (0.4,2.75);
         \fill[red!25!,opacity=.25] (2.6,0) rectangle (3.0,2.75);
         \fill[green!25!,opacity=.25] (0.4,0) rectangle (2.6,2.75);
      \end{tikzpicture}
      %\subcaption{Exemplarische Rohdaten}
   \end{minipage}
   \caption{Entfernen von irrelevanten \glspl{gls:Peak} sowie zusammenfassen naheliegender \glspl{gls:Peak}. Hier symbolisieren die roten \glspl{gls:Peak} jene, die zusammengefasst werden.}
\end{figure}

% `\glsentrytext` funktioniert nicht für `\glspl`
\subsection{Konvertierung von \glspl{gls:MassSpek}}
Das Ziel der Konvertierung ist das Erzeugen eines \gls{gls:SpecGraph}en. Um von einem \gls{gls:MassSpek} zu einem \gls{gls:SpecGraph}en zu kommen, werden die \glspl{gls:Peak}, die nach der Datenaufbereitung (Siehe ...) übrig bleiben, als Knoten gewertet. Dazu kommt ein Start- und Endknoten. Jeder Knoten bekommt eine Gewichtung; diese Gewichtung entspricht der Stärke des \gls{gls:Peak}s.

\newcommand{\colorA}{white!30!green}
\newcommand{\colorB}{black!10!yellow}
\newcommand{\colorC}{white!40!red}
\newcommand{\colorD}{white!25!orange}
\newcommand{\colorE}{white!45!blue}
\newcommand{\colorF}{white!5!magenta}
\newcommand{\nodeFontSize}{\scriptsize}
\newcommand{\nodeScaleFactor}{100}
\newcommand{\round}[1]{\pgfmathprintnumber[precision=0]{#1}}
\newcommand{\rawA}{ln(1.7)}
\newcommand{\rawB}{ln(2.0)}
\newcommand{\rawC}{ln(2.65)}
\newcommand{\rawD}{ln(1.0+5*0.15)}
\newcommand{\rawE}{ln(1.85)}
\newcommand{\rawF}{ln(2.6)}
\newcommand{\valueA}{\pgfmathparse{int(\rawA*\nodeScaleFactor)}\pgfmathresult}
\newcommand{\valueB}{\pgfmathparse{int(\rawB*\nodeScaleFactor)}\pgfmathresult}
\newcommand{\valueC}{\pgfmathparse{int(\rawC*\nodeScaleFactor)}\pgfmathresult}
\newcommand{\valueD}{\pgfmathparse{int(\rawD*\nodeScaleFactor)}\pgfmathresult}
\newcommand{\valueE}{\pgfmathparse{int(\rawE*\nodeScaleFactor)}\pgfmathresult}
\newcommand{\valueF}{\pgfmathparse{int(\rawF*\nodeScaleFactor)}\pgfmathresult}

\begin{figure}[htb]
   \centering
      \begin{tikzpicture}[scale=\tikzScale*1.5, baseline=(current bounding box.center)]
         \draw [<->,thick] (0,2.75) node (yaxis) [above] {\yAxisUnit}
         |- (3,0) node (xaxis) [below] {\xAxisUnit};

         \draw[thick] (0.6,0) -- (0.6,{ln(1.7)}) node [right, rotate=90, color=\colorA] {\nodeFontSize\textbf{A} \valueA};
         \draw[thick] (0.8,0) -- (0.8,{ln(1.2)});
         \draw[thick] (1.0,0) -- (1.0,{ln(1.1)});

         \draw[thick] (1.2,0) -- (1.2,{ln(2.65)}) node [right, rotate=90,
         color=\colorC] {\nodeFontSize\textbf{C} \valueC};
         \draw[thick] (1.4,0) -- (1.4,{ln(1.4)});
         \draw[thick] (1.6,0) -- (1.6,{ln(1.2)});
         \draw[thick] (1.8,0) -- (1.8,{ln(1.3)});
         \draw[thick] (2.0,0) -- (2.0,{ln(1.8)}) node [right, rotate=90, color=\colorE] {\nodeFontSize\textbf{E} \valueE};

         \draw[thick] (1.025,0) -- (1.025,{ln(2.0)}) node [right, rotate=90, color=\colorB] {\nodeFontSize\textbf{B} \valueB};
         \draw[thick] (1.9,0) -- (1.9,{ln(1.4)});
         \draw[thick] (2.2,0) -- (2.2,{ln(2.6)}) node [right, rotate=90, color=\colorF] {\nodeFontSize\textbf{F} \valueF};
         \draw[thick] (2.5,0) -- (2.5,{ln(1.25)});

         \draw[thick] (1.2+1*0.05,0) -- (1.2+1*0.05,{ln(1.0+1*0.15)});
         \draw[thick] (1.2+3*0.05,0) -- (1.2+3*0.05,{ln(1.0+3*0.15)});
         \draw[thick] (1.2+5*0.05,0) -- (1.2+5*0.05,{ln(1.0+5*0.15)}) node [right, rotate=90, color=\colorD] {\nodeFontSize\textbf{D} \valueD};
      \end{tikzpicture}
      \caption{Ausgewählte \glspl{gls:Peak} mit einem exemplarischen x Wert.}
\end{figure}

\newcommand{\modVal}{4}

Gerichtete Kanten zwischen den Knoten werden ausgebildet, wenn diese eine Differenz von genau einer oder zwei Aminosäurereste\footnote{Da eine Aminosäure vielerlei an Reste besitzen kann, ergeben sich mehr als 40 Differenzen, die diese Bedingung erfüllen.} besitzen. Der Einfachheit halber wird im folgenden eine Kante ausgebildet, wenn die Differenz genau \textbf{\modVal} \space beträgt.

% Um einzele Knotennamen einzufärben: \textcolor{\colorA}{A}
\newcommand{\findRaw}[1]{\csname raw#1\endcsname}
\newcommand{\findValue}[1]{\csname value#1\endcsname}
\newcommand{\findColor}[1]{\csname color#1\endcsname}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\newcommand{\tableRow}[2]
{%
   % Welche Zeile soll farblich hinterlegt werden ?
   \pgfmathparse{Mod(abs(int(\findRaw{#1}*\nodeScaleFactor) - int(\findRaw{#2}*\nodeScaleFactor)),\modVal)}
   \pgfmathtruncatemacro\myresult{\pgfmathresult==0.0?1:0}
   %\ifthenelse{\myresult=1}{A}{B}
   \ifnum\myresult=1 A \else B \fi

   (#1,#2) &
   \findValue{#1} &
   \findValue{#2} &
   \pgfmathparse{abs(int(\findRaw{#1}*\nodeScaleFactor) - int(\findRaw{#2}*\nodeScaleFactor))}\round{\pgfmathresult} &

   % Hilfreiche Infos für das Erstellen von Ausdrücken: https://tikz.dev/math-parsing
   \pgfmathparse{Mod(abs(int(\findRaw{#1}*\nodeScaleFactor) - int(\findRaw{#2}*\nodeScaleFactor)),\modVal)}
   % https://www.reddit.com/r/LaTeX/comments/57ck5p/tikz_which_conditionals_to_use_to_compare_numbers/
   \pgfmathtruncatemacro\myresult{\pgfmathresult==0.0?1:0}
   \round{\pgfmathresult}
   \ifthenelse{\myresult=1}{\cmark}{\xmark}
   \\
}
% Hilfestellung: https://tex.stackexchange.com/questions/604496/how-to-generate-beautiful-tables-in-latex
\begin{table}[H]
    \centering
    \begin{tabular}{lllcc}
        \toprule
        \thead{\textbf{$\mathbf{(u,v)}$}} & \thead{$\mathbf{u}$} & \thead{$\mathbf{v}$} & \thead{$\mathbf{\Delta(u,v)}$} & \thead{$\Delta(u,v)\bmod\modVal$}\\
        \midrule
        \tableRow{A}{B}
        \tableRow{A}{C}
        \tableRow{A}{D}
        \tableRow{A}{E}
        \tableRow{A}{F}
        \tableRow{B}{C}
        \tableRow{B}{D}
        \tableRow{B}{E}
        \tableRow{B}{F}
        \tableRow{C}{D}
        \tableRow{C}{E}
        \tableRow{C}{F}
        \tableRow{D}{E}
        \tableRow{D}{F}
        \tableRow{E}{F}
        \bottomrule
    \end{tabular}
    \caption{Bestimmung der Kanten}
\end{table}

Darstellung der Daten als gewichteter, gerichteter azyklischer Graph. Zusätzlich benötigt der Graph noch separate Start- und Zielknoten; diese sind für die späteren Berechnungen unerlässlich.

\newcommand{\printVertices}[2]%
{%
   \Vertex[x=-8,y=0]{Start}
   \Vertex[x=8,y=0]{End}
   \foreach \x [count=\xi] in {#1}
   {%
      \foreach \y [count=\yi] in {#2}
      {%
         \ifthenelse{\xi=\yi}{
         \tikzstyle{VertexStyle}=[shape=circle,fill=\y,draw=black,line width=0.75pt]
         \Vertex[x=-7+\xi*2,y=0]{\x}}{\break}
      }
   }
}
% https://tex.stackexchange.com/questions/245448/adjusting-edge-and-vertex-label
\begin{figure}[htb]
   \centering
   \begin{tikzpicture}[scale=0.75,transform shape]
      \tikzstyle{VertexStyle}=[shape=circle,fill=white,draw=black,line width=1pt]

      \printVertices{A,B,C,D,E,F}{\colorA, \colorB, \colorC, \colorD, \colorE, \colorF}

      \tikzstyle{LabelStyle}=[fill=white, sloped]
      \tikzstyle{EdgeStyle}=[bend left, post]
      \Edge[label=$0$](Start)(A)
      \Edge[label=$0$](F)(End)
      \tikzstyle{EdgeStyle}=[bend right, post]
      \Edge[label=$16$](A)(B)
      \tikzstyle{EdgeStyle}=[bend left, post]
      \Edge[label=$44$](A)(C)
      \Edge[label=$8$](A)(E)
      \tikzstyle{EdgeStyle}=[bend right, post]
      \Edge[label=$28$](B)(C)
      \Edge[label=$8$](B)(E)
      \Edge[label=$36$](C)(E)
      \tikzstyle{EdgeStyle}=[bend left, post]
      \Edge[label=$40$](D)(F)
   \end{tikzpicture}
   \caption{Erzeugter DAG}
\end{figure}

Bereits an diesem Minimalbeispiel ist zu erkennen, dass die gebildeten Knoten in einem \glspl{gls:SpecGraph} nur wenige ausgehende Kanten besitzen. Dies ist nicht dem Beispiel geschuldet sondern ist tatsächlich auch in der Praxis der Regelfall. Dies ist eine hilfreiche Beobachtung für die Datenauswertung (siehe Abschnitt~\ref{Datenauswertung} \gerquot{\titleref{Datenauswertung}}).


\subsection{Datenauswertung}\label{Datenauswertung}
Um nun aus dem Graphen die Peptidsequenz zu gewinnen müssen alle längsten Pfade im DAG gefunden werden. Da die Kanten gewichtet sind, kann es durchaus mehrere längste Pfade geben. Gleichwohl es Algorithmen für das Problem des längsten Pfades in einem Graphen gibt, handelt es sich hierbei um ein $NP$-schweres Problem. Es existiert also (wahrscheinlich) kein effizienter Algorithmus. Erschwerend kommt hinzu, dass der Graph nicht zwingend ein zusammenhängender Graph sein muss \dashAndSpace auch wenn dies meist der Fall ist. Der Graph muss daher vor Berechnungsbeginn auf diese Eigenschaft hin überprüft werden.

Im Falle der \glspl{gls:SpecGraph} existiert die Eigenschaft, dass solche Graphen meist eine geringe Dichte an Kanten aufweisen. Dies hat den positiven Effekt, dass die Anzahl an überhaupt möglichen längsten Pfaden recht gering ist. Zusätzlich dazu kann die Warteschlange, die in den longest Path DAG Algorithmen verwendet werden, angepasst werden. Da die Gewichtung der Kanten als eine Art \gerquot{Wahrscheinlichkeit}, dass die nächste Kante die reale Peptidsequenz darstellt, interpretiert werden kann, kann eine priorisierte Warteschlange verwendet werden, die die Laufzeit ebenfalls verbessert. In Summe führen diese Eigenschaften der \glspl{gls:SpecGraph} dazu, dass das längste Pfade Problem in solchen Fällen auf die Laufzeit $\mathcal{O}(abs(E) + log(d))$ reduziert werden kann.\\

Zusammengefasst: Es wird versucht die speziellen Eigenschaften der Graphen auszunutzen, um die Laufzeit zu verbessern.


\section{Ergebnisse/Evaluierung}
Im folgenden Kapitel werden die Probleme, die in der Praxis bei der Verwendung des Verfahrens auftreten, erläutert und mögliche Lösungsansätze aufgezeigt.

\subsection{Probleme in der Praxis}
\subsubsection{Qualität der Messwerte}
Obwohl eine Datenaufbereitung stattfindet, ist das Verfahren bei der Verwendung von \glspl{gls:SpecGraph} stark auf die Genauigkeit der Messwerte angewiesen. Zwar sind durch technische Fortschritte bei der \gls{gls:TMassSpek} die Daten hochwertiger geworden; dennoch gestaltet sich das Sequenzieren von unbekannten Peptidsequenzen als schwierig. Mit heutigen Gerätschaften lassen sich bei der Verwendung des genannten Verfahrens bis zu 13 Peptide mit einer durchschnittlichen Genauigkeit von 94\% ermitteln. Danach nimmt diese sprunghaft ab. Für brauchbare Ergebnisse wird \dashAndSpace je nach Literatur \dashAndSpace eine Trefferquote von 90-95\% vorausgesetzt.
\subsubsection{Fehlende Betrachtung der \glsentrytext{gls:StereoIsomerie}}\label{FehlendeStereoInfos}
Das komplette Verfahren basiert auf das Masse-Ladungs-Verhältnis, sodass Stereoinformationen schlicht nicht ermittelt werden können. Es kann zwar mithilfe einer energetischen Betrachtung bestimmt werden welche \glspl{gls:StereoIsomer} in welchen Verhältnis auftreten (müssten). Dabei handelt es sich allerdings lediglich um eine grobe Abschätzung.
\subsubsection{Identifikation der Aminosäuren über Massendifferenz}
Die Grundidee bei der Identifikation von Aminosäuren ist die Betrachtung der Massendifferenzen zwischen zwei \glspl{gls:Peak}. Zwar liefert dieser Ansatz häufig passende Ergebnisse. Dennoch ist solch eine Differenz nicht in der Lage jede Aminosäure immer eindeutig zu identifizieren, da bestimmte Kombinationen (fast) gleiche Differenzen besitzen. Der Algorithmus, der die Gewichtungen bestimmt, arbeitet nur mit ganzzahligen Werten. Dadurch gehen leichte Unterschiede, die durch die Isotope (insb. die des Kohlenstoffes) begründet sind, meist durch die Float Integer Konvertierung verloren.

\subsection{Lösungsansätze}
\subsubsection{Verbesserung der Ergebnisse durch Machine Learning}
Bei der Sequenzierung werden ab einer gewissen Länge unweigerlich Fehler eintreten.\cite[S.621,Figure 5]{pNovoPlus} Dadurch, dass nicht jede Peptidsequenz gleich wahrscheinlich ist\footnote{Dies ist u.a. dadurch begründet, dass die Reste der Aminosäuren sich gegenseitig beeinflussen (können), sodass bestimmte Sequenzen energetisch ungünstig sind und lediglich vermindert auftreten.}, können mittels Machine Learning grundsätzlich die Ergebnisse verbessert werden. insbesondere dann, wenn die ermittelte Differenz keinen eindeutigen Rückschluss auf die Aminosäure zulässt.

\section{Zusammenfassung}
Im letzten Kapitel werden die ungelösten Probleme genannt und erklärt warum diese eine Relevanz für die Praxis haben. Am Ende findet eine kritische Betrachtung des Verfahrens im allgemeinen statt.

\subsection{Ungelöste Probleme}
Wie bereits in \ref{FehlendeStereoInfos} erwähnt, kann das Verfahren designbedingt keine Stereoinformationen ermitteln. Daher ist es in diesem Fall besonders wichtig abzuschätzen, ob das Fehlen dieser Informationen tatsächlich eine Relevanz hat. Wenn nur die Peptidsequenz betrachtet werden soll, dann stellt dies kein Problem dar. Aber sobald jedweige Abschätzungen anhand der ermittelten Sequenz stattfinden soll, dann kann das Fehlen jener Informationen zu massiven Fehlern führen.\\

Wenn für die Verbesserung der Ergebnisse Machine Learning in Betracht kommt, dann muss dabei berücksichtigt werden, dass dadurch unter Umständen einer der großen Vorteile der \gls{gls:DeNovo} verloren geht \dashAndSpace und zwar dass keine Vorinformationen für die Sequenzierung notwendig sind. Hierbei kommt es auf den konkreten Anwendungsfall an, ob das Verlieren dieser Eigenschaft eine Bedeutung besitzt.

\subsection{Kritische Betrachtung}
Die \gls{gls:DeNovo} mit der Unterstützung von \glspl{gls:SpecGraph} stellt eine Möglichkeit dar Polypeptide mit bis zu einer Länge von etwa 12 Peptiden ausreichend zuverlässig zu bestimmen. Die Autoren des Papers \cite{OpenPNovo} haben die Software frei zur Verfügung gestellt, sodass sie in jedem Fall ein Blick wert ist.
Gegenüber anderen Ansätzen ist das Verfahren zwar konkurrenzfähig, allerdings nicht immer die beste Wahl \cite[650]{OpenPNovo}. Die Grundidee mittels der Massendifferenz auf die Aminosäuren zu schließen wird nie fehlerfrei sein, sodass dieses Verfahren weniger die bereits vorhandenen Systeme ersetzten kann, sondern eher ein weiteres Werkzeug für die \gls{gls:DeNovo} darstellt.

\begingroup
\setlength{\emergencystretch}{.5em}
\printbibliography
\endgroup

\end{document}
%%%%% %%%%% %%%%% %%%%% %%%%% \end{document} %%%%% %%%%% %%%%% %%%%% %%%%%
